// –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã—Ö –º–æ–¥—É–ª–µ–π –∏ –º–æ–¥–µ–ª–µ–π
require('dotenv').config();
const express = require('express');
const bodyParser = require('body-parser');
const cors = require('cors');
const mongoose = require('mongoose');
const axios = require('axios');
const app = express();
const port = process.env.PORT || 3000;
const nodemailer = require('nodemailer');
const crypto = require('crypto');
const jwt = require('jsonwebtoken');


const passwordResetSchema = new mongoose.Schema({
  email: String,
  token: String,
  expiresAt: Date,
});

const PasswordReset = mongoose.model('PasswordReset', passwordResetSchema);

const promoCodeSchema = new mongoose.Schema({
  code: { type: String, required: true, unique: true },
  expiresAt: { type: Date, required: true },
});

const PromoCode = mongoose.model('PromoCode', promoCodeSchema);

// –æ—Ç–ø—Ä–∞–≤–∫–∞ e-mail
async function sendResetEmail(email, token) {
  const transporter = nodemailer.createTransport({
    service: 'gmail',
    auth: {
      user: process.env.EMAIL_USER,
      pass: process.env.EMAIL_PASS,
    }
  });

  const resetLink = `${process.env.FRONTEND_URL}/?token=${token}`;

  await transporter.sendMail({
    from: `"Caprizon" <${process.env.EMAIL_USER}>`,
    to: email,
    subject: "Password Reset",
    html: `<p>To reset your password, click the link below:</p><a href="${resetLink}">${resetLink}</a>`
  });
}


app.use(cors());
app.use(bodyParser.json());



// –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ MongoDB
//mongoose.connect(process.env.MONGODB_URI, { useNewUrlParser: true, useUnifiedTopology: true });

mongoose.connect(process.env.MONGODB_URI, {
  useNewUrlParser: true,
  useUnifiedTopology: true,
});

const db = mongoose.connection;
db.on('error', console.error.bind(console, 'MongoDB error:'));
db.once('open', () => console.log('‚úÖ Connected to MongoDB'));

// –°—Ö–µ–º—ã
const tokenSchema = new mongoose.Schema({
  name: String,
  symbol: String,
  adminId: { type: String, required: true },
  totalSupply: { type: Number, default: 0 },
  members: { type: [String], default: [] },
  rules: { type: [String], default: [] },
  lastRulesUpdate: { type: Date },
});

// üîí –£–Ω–∏–∫–∞–ª—å–Ω–æ—Å—Ç—å –∫–æ–º–±–∏–Ω–∞—Ü–∏–∏ name + adminId
tokenSchema.index({ name: 1, adminId: 1 }, { unique: true });

const userSchema = new mongoose.Schema({
  name: String,
  email: String,
  password: String,
  token: String,
  role: { type: String, default: 'user' },
  tokenBalances: { type: Map, of: Number, default: {} },
  isPremium: { type: Boolean, default: false },
  premiumUntil: { type: Date },
  transactionCount: { type: Number, default: 0 },
  createdTokens: { type: Number, default: 0 },
});

const transactionSchema = new mongoose.Schema({
  from: String,
  to: String,
  amount: Number,
  message: String,
  tokenId: String,
  timestamp: { type: Date, default: Date.now },
});

const User = mongoose.model('User', userSchema);
const Token = mongoose.model('Token', tokenSchema);
const Transaction = mongoose.model('Transaction', transactionSchema);

// –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è
app.post('/api/register', async (req, res) => {
  const { email, password, name } = req.body;
  const existing = await User.findOne({ email });
  if (existing) return res.status(400).json({ error: 'Email already registered' });

  const user = new User({
  name,
  email,
  password,
  token: 'token-' + Math.random().toString(36).substr(2),
  createdTokens: 0,       
  isPremium: false,       
});

  await user.save();
  res.json({ token: user.token, userId: user._id.toString() });
});

// GET /api/users/me
app.get('/api/users/me', async (req, res) => {
  const token = req.headers.authorization?.split(' ')[1];
  const user = await User.findOne({ token }, 'name email isPremium');
  if (!user) return res.status(403).json({ error: 'Invalid token' });
 if (user.premiumUntil && user.premiumUntil < new Date()) {
    user.isPremium = false;
    await user.save();
  }

  res.json({
    userId: user._id.toString(),
    name: user.name,
    email: user.email,
    isPremium: user.isPremium,
  });
});


// –ù–æ–≤–∞—è —Å—Ö–µ–º–∞ –¥–ª—è –∑–∞–ø—Ä–æ—Å–æ–≤ –Ω–∞ —Ç–æ–∫–µ–Ω—ã
const requestSchema = new mongoose.Schema({
  requesterId: { type: String, required: true },   // –∫—Ç–æ –∑–∞–ø—Ä–æ—Å–∏–ª
  ownerId:     { type: String, required: true },   // —É –∫–æ–≥–æ –∑–∞–ø—Ä–∞—à–∏–≤–∞—é—Ç
  tokenId:     { type: String, required: true },
  amount:      { type: Number, required: true },
  message:     { type: String },
  status:      { type: String, enum: ['pending','approved','rejected'], default: 'pending' },
  createdAt:   { type: Date, default: Date.now },
});

// –ú–æ–¥–µ–ª–∏

const Request = mongoose.model('Request', requestSchema);

// –°–æ–∑–¥–∞–Ω–∏–µ —Ç–æ–∫–µ–Ω–∞
app.post('/api/tokens/create', async (req, res) => {
  const header = req.headers.authorization?.split(' ')[1];
  const { name, symbol } = req.body;

  const admin = await User.findOne({ token: header });
console.log('‚ñ∂Ô∏è –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è —Ç–æ–∫–µ–Ω–∞');
console.log('admin.token =', admin.token);
console.log('admin.isPremium =', admin.isPremium, '| typeof:', typeof admin.isPremium);
console.log('admin.createdTokens =', admin.createdTokens, '| typeof:', typeof admin.createdTokens);
  if (!admin) return res.status(403).json({ error: 'Admin not found or invalid token' });
  if (!admin.isPremium && admin.createdTokens >= 1) {
    return res.status(403).json({ error: 'Free users can only create one token' });
  }
  // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ø–æ–≤—Ç–æ—Ä –∏–º–µ–Ω–∏ —É —Ç–æ–≥–æ –∂–µ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞
  const existing = await Token.findOne({ name, adminId: admin._id.toString() });
  if (existing) return res.status(400).json({ error: 'You already created a token with this name' });

  const token = new Token({
    name,
    symbol,
    adminId: admin._id.toString(),
    members: [admin._id.toString()] // –î–æ–±–∞–≤–ª—è–µ–º –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞ –≤ —Å–ø–∏—Å–æ–∫ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤
  });
  admin.createdTokens += 1;
  await admin.save();
  await token.save();

  res.json({ tokenId: token._id.toString() });
});

app.post('/api/forgot-password', async (req, res) => {
  const { email } = req.body;
  const user = await User.findOne({ email });
  if (!user) return res.status(404).json({ error: 'User not found' });

  const token = crypto.randomBytes(32).toString('hex');
  const expiresAt = new Date(Date.now() + 1000 * 60 * 15); // 15 –º–∏–Ω—É—Ç

  await PasswordReset.deleteMany({ email }); // —É–¥–∞–ª–∏—Ç—å —Å—Ç–∞—Ä—ã–µ
  await new PasswordReset({ email, token, expiresAt }).save();
  await sendResetEmail(email, token);

  res.json({ success: true });
});

// –ø—Ä–æ–º–æ –∫–æ–¥ 
app.post('/api/promo-codes/redeem', async (req, res) => {
  const { code } = req.body;
  const authToken = req.headers.authorization?.split(' ')[1];
  const user = await User.findOne({ token: authToken });
  if (!user) return res.status(403).json({ error: 'Invalid token' });

  const promo = await PromoCode.findOne({ code });
  if (!promo) return res.status(404).json({ error: 'Promo code not found' });
  if (promo.expiresAt < new Date()) return res.status(400).json({ error: 'Promo code expired' });

  // –ù–∞–∑–Ω–∞—á–∞–µ–º Premium –¥–æ +1 –≥–æ–¥–∞
  const oneYearLater = new Date();
  oneYearLater.setFullYear(oneYearLater.getFullYear() + 1);
  user.isPremium = true;
  user.premiumUntil = oneYearLater;
  await user.save();
  user.latestReceipt = 'PROMO'; // —á—Ç–æ–±—ã `check-subscription` –Ω–µ –ø–µ—Ä–µ–∑–∞–ø–∏—Å—ã–≤–∞–ª isPremium

  res.json({ success: true, message: 'Premium activated for 1 year using promo code' });
});

// –°–æ–∑–¥–∞–Ω–∏–µ –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ –ø—Ä–æ–º–æ-–∫–æ–¥–∞ FRIENDS2025 (–¥–ª—è –∞–¥–º–∏–Ω–∞ –∏–ª–∏ –≤—Ä—É—á–Ω—É—é)
app.post('/api/promo-codes/create-once', async (req, res) => {
  const existing = await PromoCode.findOne({ code: 'FRIENDS2025' });
  if (existing) return res.status(400).json({ error: 'Promo code already exists' });

  await new PromoCode({
    code: 'FRIENDS2025',
    expiresAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // 1 –º–µ—Å—è—Ü
  }).save();

  res.json({ success: true });
});


app.post('/api/reset-password', async (req, res) => {
  const { token, newPassword } = req.body;
  const reset = await PasswordReset.findOne({ token });

  if (!reset || reset.expiresAt < new Date()) {
    return res.status(400).json({ error: 'Invalid or expired token' });
  }

  const user = await User.findOne({ email: reset.email });
  if (!user) return res.status(404).json({ error: 'User not found' });

  user.password = newPassword;
  await user.save();
  await PasswordReset.deleteOne({ token });

  res.json({ success: true });
});

// –õ–æ–≥–∏–Ω
app.post('/api/login', async (req, res) => {
  const { email, password } = req.body;
  const user = await User.findOne({ email, password });
  if (!user) return res.status(401).json({ error: 'Invalid credentials' });

  res.json({ token: user.token, userId: user._id.toString() });
});

// –≠–Ω–¥–ø–æ–∏–Ω—Ç: –ø–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö —Ç–æ–∫–µ–Ω–æ–≤ (–≤–∫–ª—é—á–∞—è adminId)
app.get('/api/tokens', async (req, res) => {
  try {
    const tokens = await Token.find().lean();
    res.json(tokens.map(t => ({
      tokenId: t._id.toString(),
      name: t.name,
      symbol: t.symbol,
      totalSupply: t.totalSupply,
      adminId: t.adminId,
      members: t.members,
      lastRulesUpdate: t.lastRulesUpdate,
    })));
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// –≠–º–∏—Å—Å–∏—è —Ç–æ–∫–µ–Ω–∞ (mint)
app.post('/api/tokens/mint', async (req, res) => {
  try {
    const header = req.headers.authorization?.split(' ')[1];
    const { tokenId, userId, amount } = req.body;

    const admin = await User.findOne({ token: header });
    if (!admin) return res.status(403).json({ error: 'Admin authentication failed' });

    const token = await Token.findById(tokenId);
    if (!token) return res.status(404).json({ error: 'Token not found' });

    const target = await User.findById(userId);
    if (!target) return res.status(404).json({ error: 'Target user not found' });

    if (token.adminId !== admin._id.toString()) {
      return res.status(403).json({ error: 'Access denied' });
    }
    if (!token.members.includes(userId)) {
      return res.status(403).json({ error: 'User not in token members' });
    }

    // –û–±–Ω–æ–≤–ª—è–µ–º –±–∞–ª–∞–Ω—Å—ã
    const current = target.tokenBalances.get(tokenId) || 0;
    target.tokenBalances.set(tokenId, current + amount);
    await target.save();

    // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –æ–±—â–µ–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ
    token.totalSupply += amount;
    await token.save();

    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∑–∞–ø–∏—Å—å –æ–± —ç–º–∏—Å—Å–∏–∏
    await new Transaction({
      from: admin._id.toString(),
      to: userId,
      amount,
      message: 'Mint Tokens',
      tokenId,
    }).save();

    res.json({ success: true });
  } catch (err) {
    console.error('Mint failed: ', err);
    res.status(500).json({ error: 'Internal server error' });
  }
});

app.post('/api/users/upgrade', async (req, res) => {
  console.log('üöÄ /api/users/upgrade called');
  const authToken = req.headers.authorization?.split(' ')[1];
  console.log('üîê –ü–æ–ª—É—á–µ–Ω authToken:', authToken);
  console.log('üì® Authorization header:', req.headers.authorization);
  const { receipt, productId } = req.body;

  if (!authToken || !receipt || !productId) {
    return res.status(400).json({ error: 'Missing token, receipt or productId' });
  }

  const user = await User.findOne({ token: authToken });
  if (!user) return res.status(403).json({ error: 'Invalid token' });

  // StoreKit (Xcode Simulator)
  if (receipt.startsWith("MIAGCSqGSIb3DQEHAqCA")) {
    user.isPremium = true;
    user.latestReceipt = receipt;
    await user.save();
    return res.json({ success: true, note: 'StoreKit test receipt accepted' });
  }

  try {
    const payload = {
      'receipt-data': receipt,
      'password': process.env.APPLE_SHARED_SECRET
    };

    let response = await axios.post('https://buy.itunes.apple.com/verifyReceipt', payload, {
      headers: { 'Content-Type': 'application/json' }
    });

    if (response.data.status === 21007) {
      console.log("‚ÑπÔ∏è –°—Ç–∞—Ç—É—Å 21007 ‚Äî –ø—Ä–æ–±—É–µ–º Sandbox...");
      try {
        response = await axios.post('https://sandbox.itunes.apple.com/verifyReceipt', payload, {
          headers: { 'Content-Type': 'application/json' }
        });
      } catch (sandboxErr) {
        console.error("‚ùå –û—à–∏–±–∫–∞ Sandbox-–∑–∞–ø—Ä–æ—Å–∞:", sandboxErr);
        // –í–†–ï–ú–ï–ù–ù–´–ô –û–ë–•–û–î: –∞–∫—Ç–∏–≤–∏—Ä—É–µ–º –ø–æ–¥–ø–∏—Å–∫—É –Ω–µ—Å–º–æ—Ç—Ä—è –Ω–∞ –æ—à–∏–±–∫—É
        user.isPremium = true;
        await user.save();
        return res.json({ success: true, bypass: true, note: 'Sandbox verification failed ‚Äî temporary bypass used' });
      }
    }

    console.log("üì¶ –§–∏–Ω–∞–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç –æ—Ç Apple:", JSON.stringify(response.data, null, 2));

    if (response.data.status !== 0) {
      console.error("‚ùå –ù–µ–≤–∞–ª–∏–¥–Ω—ã–π —á–µ–∫:", JSON.stringify(response.data, null, 2));
      // –í–†–ï–ú–ï–ù–ù–´–ô –û–ë–•–û–î: –∞–∫—Ç–∏–≤–∏—Ä—É–µ–º –ø–æ–¥–ø–∏—Å–∫—É –Ω–µ—Å–º–æ—Ç—Ä—è –Ω–∞ —Å—Ç–∞—Ç—É—Å –æ—à–∏–±–∫–∏
      user.isPremium = true;
      await user.save();
      return res.json({ success: true, bypass: true, note: 'Invalid receipt status ‚Äî temporary bypass used' });
    }

    const latestInfo = response.data.latest_receipt_info || [];
    const found = latestInfo.some(entry => entry.product_id === productId);

    if (!found && response.data.environment === 'Sandbox') {
      console.log('‚ö†Ô∏è –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –ø—Ä–æ–≤–µ—Ä–∫—É productId –≤ Sandbox');
    } else if (!found) {
      // –í–†–ï–ú–ï–ù–ù–´–ô –û–ë–•–û–î: –∞–∫—Ç–∏–≤–∏—Ä—É–µ–º –ø–æ–¥–ø–∏—Å–∫—É –Ω–µ—Å–º–æ—Ç—Ä—è –Ω–∞ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–µ productId
      user.isPremium = true;
      await user.save();
      return res.json({ success: true, bypass: true, note: 'Product ID not found ‚Äî temporary bypass used' });
    }

    user.isPremium = true;
    await user.save();

    res.json({ success: true });
  } catch (err) {
    console.error('Apple receipt verification failed:', err);
    // –í–†–ï–ú–ï–ù–ù–´–ô –û–ë–•–û–î: –∞–∫—Ç–∏–≤–∏—Ä—É–µ–º –ø–æ–¥–ø–∏—Å–∫—É –Ω–µ—Å–º–æ—Ç—Ä—è –Ω–∞ –∏—Å–∫–ª—é—á–µ–Ω–∏–µ
    user.isPremium = true;
    await user.save();
    res.json({ success: true, bypass: true, note: 'Receipt verification exception ‚Äî temporary bypass used' });
  }
});

// –£–¥–∞–ª–∏—Ç—å —Å–≤–æ–π –∑–∞–ø—Ä–æ—Å (–ª—é–±–æ–π —Å—Ç–∞—Ç—É—Å)
app.delete('/api/requests/:requestId', async (req, res) => {
  try {
    const header = req.headers.authorization?.split(' ')[1];
    const user = await User.findOne({ token: header });
    if (!user) return res.status(403).json({ error: 'Invalid token' });

    const { requestId } = req.params;
    const request = await Request.findById(requestId);
    if (!request) return res.status(404).json({ error: 'Request not found' });

    if (request.requesterId !== user._id.toString()) {
      return res.status(403).json({ error: 'You can only delete your own requests' });
    }

    await request.deleteOne();
    res.json({ success: true, message: 'Request deleted' });
  } catch (err) {
    console.error('Error deleting request:', err);
    res.status(500).json({ error: 'Internal server error' });
  }
});


// –≠–Ω–¥–ø–æ–∏–Ω—Ç –¥–ª—è –ø–æ–∏—Å–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ e-mail
app.post('/api/users/search', async (req, res) => {
  const { email } = req.body;
  console.log('Received email for search:', email); // –õ–æ–≥–∏—Ä—É–µ–º email –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏

  const user = await User.findOne({ email });
  if (!user) {
    console.log('User not found with email:', email); // –õ–æ–≥–∏—Ä—É–µ–º, –µ—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω
    return res.status(404).json({ error: 'User not found' });
  }

  console.log('User found:', user); // –õ–æ–≥–∏—Ä—É–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –Ω–∞–π–¥–µ–Ω–Ω–æ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ
  res.json({ userId: user._id.toString() });
});

// –ü–æ–ª—É—á–∏—Ç—å –∏–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ userId
app.get('/api/users/by-id/:id', async (req, res) => {
  const user = await User.findById(req.params.id, 'name email');
  if (!user) return res.status(404).json({ error: 'User not found' });
  res.json({ name: user.name, email: user.email });
});

app.post('/api/tokens/set-rules', async (req, res) => {
  const header = req.headers.authorization?.split(' ')[1];
  const { tokenId, rules } = req.body;

  const admin = await User.findOne({ token: header });
  const token = await Token.findById(tokenId);

  if (!admin || !token || token.adminId !== admin._id.toString()) {
    return res.status(403).json({ error: 'Access denied' });
  }

  token.rules = Array.isArray(rules) ? rules : [];
  token.lastRulesUpdate = new Date();
  await token.save();

  res.json({ success: true });
});

// –ü–æ–ª—É—á–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
app.get('/api/requests/sent/:requesterId', async (req, res) => {
  try {
    const header = req.headers.authorization?.split(' ')[1];
    const user = await User.findOne({ token: header });

    if (!user || user._id.toString() !== req.params.requesterId) {
      return res.status(403).json({ error: 'Invalid auth or requesterId mismatch' });
    }

    const requests = await Request.find({ requesterId: user._id.toString() }).sort({ createdAt: -1 });

    const enriched = await Promise.all(requests.map(async (req) => {
      const owner = await User.findById(req.ownerId, 'name email');
      return {
        ...req.toObject(),
	requestId: req._id.toString(),
        ownerName: owner ? (owner.name || owner.email) : req.ownerId,
      };
    }));

    res.json(enriched);
  } catch (err) {
    console.error('Error fetching sent requests:', err);
    res.status(500).json({ error: 'Internal server error' });
  }
});

app.get('/api/tokens/:tokenId/rules', async (req, res) => {
  const token = await Token.findById(req.params.tokenId);
  if (!token) return res.status(404).json({ error: 'Token not found' });
  res.json({ rules: token.rules });
});

// –ù–∞–∑–Ω–∞—á–∏—Ç—å —É—á–∞—Å—Ç–Ω–∏–∫–∞ —Ç–æ–∫–µ–Ω–∞
app.post('/api/tokens/assign-user', async (req, res) => {
  const header = req.headers.authorization?.split(' ')[1];
  const { tokenId, userId } = req.body;

  console.log("Request body:", req.body);  // –õ–æ–≥–∏—Ä—É–µ–º –ø—Ä–∏—à–µ–¥—à–∏–µ –¥–∞–Ω–Ω—ã–µ
  console.log("Authorization header:", header);  // –õ–æ–≥–∏—Ä—É–µ–º –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–æ–Ω–Ω—ã–π —Ç–æ–∫–µ–Ω

  if (!mongoose.Types.ObjectId.isValid(userId)) {
    console.log("Invalid user ID format:", userId);  // –õ–æ–≥–∏—Ä—É–µ–º –æ—à–∏–±–∫—É —Å userId
    return res.status(400).json({ error: 'Invalid user ID format' });
  }

  const admin = await User.findOne({ token: header });
  const token = await Token.findById(tokenId);

  if (!admin || !token || token.adminId !== admin._id.toString()) {
    console.log("Access denied: Admin doesn't match or invalid token");  // –õ–æ–≥–∏—Ä—É–µ–º –æ—à–∏–±–∫—É —Å –¥–æ—Å—Ç—É–ø–æ–º
    return res.status(403).json({ error: 'Access denied' });
  }

  // –õ–æ–≥–∏—Ä—É–µ–º, —á—Ç–æ –Ω–∞—à–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
  const user = await User.findById(userId);
  if (!user) {
    console.log("User not found:", userId);  // –õ–æ–≥–∏—Ä—É–µ–º, –µ—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω
    return res.status(404).json({ error: 'User not found' });
  }

  // –õ–æ–≥–∏—Ä—É–µ–º —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤
  console.log("Token members before update:", token.members); 

  // –î–æ–±–∞–≤–ª—è–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ —Å–ø–∏—Å–æ–∫ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ —Ç–æ–∫–µ–Ω–∞
  if (!token.members.includes(userId)) {
    token.members.push(userId);
    console.log("User added to token:", userId); // –õ–æ–≥–∏—Ä—É–µ–º –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ —É—á–∞—Å—Ç–Ω–∏–∫–∞
  }

  await token.save();
  console.log("Token updated successfully:", token);  // –õ–æ–≥–∏—Ä—É–µ–º —É—Å–ø–µ—à–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ

  res.json({ success: true });
});


// –ù–∞–∑–Ω–∞—á–∏—Ç—å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞ —Ç–æ–∫–µ–Ω–∞
app.post('/api/tokens/assign-admin', async (req, res) => {
  const header = req.headers.authorization?.split(' ')[1];
  const { tokenId, userId } = req.body;

  if (!mongoose.Types.ObjectId.isValid(userId)) {
    return res.status(400).json({ error: 'Invalid user ID format' });
  }

  const admin = await User.findOne({ token: header });
  const token = await Token.findById(tokenId);

  if (!admin || !token || token.adminId !== admin._id.toString()) {
    return res.status(403).json({ error: 'Access denied' });
  }

  token.adminId = userId;
  await token.save();

  res.json({ success: true });
});

// –î–æ–±–∞–≤–∏—Ç—å —É—á–∞—Å—Ç–Ω–∏–∫–∞ —Ç–æ–∫–µ–Ω–∞
app.post('/api/tokens/add-member', async (req, res) => {
  const header = req.headers.authorization?.split(' ')[1];
  const { tokenId, userId } = req.body;

  const admin = await User.findOne({ token: header });
  const token = await Token.findById(tokenId);

  if (!admin || !token || token.adminId !== admin._id.toString()) {
    return res.status(403).json({ error: 'Access denied' });
  }

  if (!token.members.includes(userId)) {
    token.members.push(userId);
    await token.save();
  }

  res.json({ success: true });
});

// –ë–∞–ª–∞–Ω—Å—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
app.get('/api/balances/:userId', async (req, res) => {
  const token = req.headers.authorization?.split(' ')[1];
  const user = await User.findById(req.params.userId);
  if (!user || user.token !== token) return res.status(403).json({ error: 'Invalid token' });

  res.json({ balances: Object.fromEntries(user.tokenBalances) });
});

// –ü–µ—Ä–µ–≤–æ–¥ —Ç–æ–∫–µ–Ω–æ–≤
app.post('/api/transfer', async (req, res) => {
  const header = req.headers.authorization?.split(' ')[1];
  const { fromUserId, toUserId, amount, message, tokenId } = req.body;
  const amt = parseFloat(amount);

  const from = await User.findById(fromUserId);
  const to = await User.findById(toUserId);
  const token = await Token.findById(tokenId);

  if (!from || !to || from.token !== header || isNaN(amt) || amt <= 0 || !token) {
    return res.status(400).json({ error: 'Invalid transfer' });
  }
  if (!from.isPremium && from.transactionCount >= 20) {
    return res.status(403).json({ error: 'Transaction limit reached for free users' });
  }
  if (!token.members.includes(toUserId)) {
    return res.status(403).json({ error: 'Recipient not in token members' });
  }

  const fromBal = from.tokenBalances.get(tokenId) || 0;
  if (fromBal < amt) return res.status(400).json({ error: 'Insufficient funds' });

  from.tokenBalances.set(tokenId, fromBal - amt);
  const toBal = to.tokenBalances.get(tokenId) || 0;
  to.tokenBalances.set(tokenId, toBal + amt);
  from.transactionCount += 1;
  await from.save();
  await to.save();

  await new Transaction({ from: fromUserId, to: toUserId, amount: amt, message, tokenId }).save();
  res.json({ success: true });
});


// –°–æ–∑–¥–∞–Ω–∏–µ –∑–∞–ø—Ä–æ—Å–∞ –Ω–∞ –ø–æ–ª—É—á–µ–Ω–∏–µ —Ç–æ–∫–µ–Ω–æ–≤
app.post('/api/requests', async (req, res) => {
  try {
    const header = req.headers.authorization?.split(' ')[1];
    const { requesterId, ownerId, tokenId, amount, message } = req.body;
    const user = await User.findOne({ token: header });
    if (!user || user._id.toString() !== requesterId) {
      return res.status(403).json({ error: 'Invalid auth or requesterId mismatch' });
    }
    const token = await Token.findById(tokenId);
    if (!token || !token.members.includes(ownerId)) {
      return res.status(403).json({ error: 'Owner is not a member of this token' });
    }
    const reqDoc = new Request({ requesterId, ownerId, tokenId, amount, message });
    await reqDoc.save();
    res.json({ success: true, requestId: reqDoc._id.toString() });
  } catch (err) {
    console.error('Error creating request:', err);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// –ü–æ–ª—É—á–µ–Ω–∏–µ –≤—Ö–æ–¥—è—â–∏—Ö –∑–∞–ø—Ä–æ—Å–æ–≤ –¥–ª—è –≤–ª–∞–¥–µ–ª—å—Ü–∞ —Ç–æ–∫–µ–Ω–∞
app.get('/api/requests/incoming/:ownerId', async (req, res) => {
  try {
    const header = req.headers.authorization?.split(' ')[1];
    const owner = await User.findOne({ token: header });
    if (!owner || owner._id.toString() !== req.params.ownerId) {
      return res.status(403).json({ error: 'Invalid auth or ownerId mismatch' });
    }
   const requests = await Request.find({ ownerId: owner._id.toString(), status: 'pending' }).sort({ createdAt: -1 });

   const enriched = await Promise.all(requests.map(async (req) => {
   const user = await User.findById(req.requesterId, 'name email');
   return {
    ...req.toObject(),
    requesterName: user ? (user.name || user.email) : req.requesterId,
  };
}));

res.json(enriched);

  } catch (err) {
    console.error('Error fetching incoming requests:', err);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// –û—Ç–≤–µ—Ç –Ω–∞ –∑–∞–ø—Ä–æ—Å: approve –∏–ª–∏ reject
app.post('/api/requests/:requestId/respond', async (req, res) => {
  try {
    const header = req.headers.authorization?.split(' ')[1];
    const owner = await User.findOne({ token: header });
    const { action } = req.body;
    const { requestId } = req.params;

    const reqDoc = await Request.findById(requestId);
    if (!reqDoc) return res.status(404).json({ error: 'Request not found' });
    if (reqDoc.ownerId !== owner._id.toString()) {
      return res.status(403).json({ error: 'Not authorized to respond' });
    }
    if (reqDoc.status !== 'pending') {
      return res.status(400).json({ error: 'Request already handled' });
    }

    if (action === 'approve') {
      const from = await User.findById(reqDoc.ownerId);
      const to = await User.findById(reqDoc.requesterId);
      const token = await Token.findById(reqDoc.tokenId);

      const ownerBal = from.tokenBalances.get(reqDoc.tokenId) || 0;
      if (ownerBal < reqDoc.amount) {
        return res.status(400).json({ error: 'Insufficient funds' });
      }
      // –ü–µ—Ä–µ–≤–æ–¥–∏–º —Ç–æ–∫–µ–Ω—ã
      from.tokenBalances.set(reqDoc.tokenId, ownerBal - reqDoc.amount);
      const toBal = to.tokenBalances.get(reqDoc.tokenId) || 0;
      to.tokenBalances.set(reqDoc.tokenId, toBal + reqDoc.amount);
      await from.save();
      await to.save();

      // –ó–∞–ø–∏—Å—ã–≤–∞–µ–º —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é
      await new Transaction({
        from: reqDoc.ownerId,
        to: reqDoc.requesterId,
        amount: reqDoc.amount,
        message: reqDoc.message || 'Request Approved',
        tokenId: reqDoc.tokenId,
      }).save();

      // –û—Ç–º–µ—á–∞–µ–º –∑–∞–ø—Ä–æ—Å –∫–∞–∫ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã–π
      reqDoc.status = 'approved';
      await reqDoc.save();

      return res.json({ success: true, action: 'approved' });
    } else if (action === 'reject') {
      reqDoc.status = 'rejected';
      await reqDoc.save();
      return res.json({ success: true, action: 'rejected' });
    } else {
      return res.status(400).json({ error: 'Invalid action' });
    }
  } catch (err) {
    console.error('Error responding to request:', err);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// –≠–Ω–¥–ø–æ–∏–Ω—Ç –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π —Ç–æ–∫–µ–Ω–∞
app.get('/api/users/token/:tokenId', async (req, res) => {
  const { tokenId } = req.params;
  const token = await Token.findById(tokenId);

  if (!token) {
    return res.status(404).json({ error: 'Token not found' });
  }

  // –ü–æ–ª—É—á–∞–µ–º —Ç–æ–ª—å–∫–æ —Ç–µ—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π, –∫–æ—Ç–æ—Ä—ã–µ —Å–≤—è–∑–∞–Ω—ã —Å —ç—Ç–∏–º —Ç–æ–∫–µ–Ω–æ–º
  const users = await User.find({ '_id': { $in: token.members } });
  res.json(users);
});


app.delete('/api/users/delete', async (req, res) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];

  if (!token) {
    return res.status(401).json({ error: 'Token missing' });
  }

  try {
    const user = await User.findOne({ token });
    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }

    await user.deleteOne();
    res.json({ success: true, message: 'Account deleted' });
  } catch (err) {
    console.error('‚ùå Error deleting account:', err);
    res.status(500).json({ error: 'Server error' });
  }
});

// ‚úÖ –ù–æ–≤—ã–π —ç–Ω–¥–ø–æ–∏–Ω—Ç: –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–¥–ø–∏—Å–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
app.get('/api/users/check-subscription', async (req, res) => {
  const authToken = req.headers.authorization?.split(' ')[1];
  if (!authToken) return res.status(401).json({ error: 'Missing token' });

  const user = await User.findOne({ token: authToken });
  if (!user) return res.status(403).json({ error: 'Invalid token' });

    if (!user.latestReceipt || user.latestReceipt === 'PROMO') {
    return res.json({ isPremium: user.isPremium, note: 'No receipt available' });
  }

  try {
    const payload = {
      'receipt-data': user.latestReceipt,
      'password': process.env.APPLE_SHARED_SECRET
    };

    let response = await axios.post('https://buy.itunes.apple.com/verifyReceipt', payload, {
      headers: { 'Content-Type': 'application/json' }
    });

    if (response.data.status === 21007) {
      response = await axios.post('https://sandbox.itunes.apple.com/verifyReceipt', payload, {
        headers: { 'Content-Type': 'application/json' }
      });
    }

    if (response.data.status !== 0) {
      return res.status(400).json({ error: 'Invalid receipt', status: response.data.status });
    }

    const now = Date.now();
    const active = (response.data.latest_receipt_info || []).some(entry => {
      return entry.expires_date_ms && parseInt(entry.expires_date_ms) > now;
    });

    user.isPremium = active;
    await user.save();

    res.json({ isPremium: active });
  } catch (err) {
    console.error('‚ùå Subscription check failed:', err);
    res.status(500).json({ error: 'Subscription check failed' });
  }
});


// –ò—Å—Ç–æ—Ä–∏—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π –ø–æ —Ç–æ–∫–µ–Ω—É —Å –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ–º –∏–º—ë–Ω
app.get('/api/transactions/token/:tokenId', async (req, res) => {
  try {
    const txs = await Transaction.find({ tokenId: req.params.tokenId }).sort({ timestamp: -1 });

    const populated = await Promise.all(txs.map(async tx => {
      let fromUser = null;
      let toUser = null;

      try {
        fromUser = await User.findById(tx.from, 'name email');
      } catch (_) {}
      try {
        toUser = await User.findById(tx.to, 'name email');
      } catch (_) {}

      return {
        ...tx.toObject(),
        fromName: fromUser ? (fromUser.name || fromUser.email) : tx.from,
        toName: toUser ? (toUser.name || toUser.email) : tx.to,
      };
    }));

    res.json(populated);
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// –ó–∞–ø—É—Å–∫ —Å–µ—Ä–≤–µ—Ä–∞
app.listen(port, () => console.log(`üöÄ Caprizon backend running at ${port}`));
